<html>
    <body>
        <!-- Water CSS - Not required for the plugin to function -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/water.css">
        <!-- JSZip - Required for Downloading(/saving a local copy of every) Images, though not required for typical use -->
        <script src="https://unpkg.com/jszip@3.7.1/dist/jszip.js" integrity="sha384-Lqk2um7o0W+Ke7IGh8Mk9EE7g2IrhepxXvttF/iw5hFqpMjFGKP4jcKYhNLAi/ZD" crossorigin="anonymous" defer></script>
        <!--<script type="module" src="./main.js"></script> -->

        <style>
            :root {
                --background: var(--figma-color-bg-secondary) !important;
                --background-body: var(--figma-color-bg) !important;
                --button-base: var(--figma-color-bg-secondary) !important;
                --button-hover: var(--figma-color-bg-tertiary) !important;
                --text-main: var(--figma-color-text) !important;
                --info-icon: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 20 20"><path fill="rgb(12, 140, 233)" d="M7 4.75c0-.412.338-.75.75-.75h.5c.412 0 .75.338.75.75v.5c0 .412-.338.75-.75.75h-.5A.753.753 0 0 1 7 5.25zM10 12H6v-1h1V8H6V7h3v4h1z"/><path fill="rgb(12, 140, 233)" d="M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0m0 14.5a6.5 6.5 0 1 1 0-13a6.5 6.5 0 0 1 0 13"/></svg>');
            }
            input {
                accent-color: var(--background) !important;
                width: 100%;
            }
            summary {
                width: 100%;
            }

            .info-marker {
                position: absolute;
                background-image: var(--info-icon);
                background-repeat: no-repeat;
                background-size: 2rem;
                height: 2rem;
                width: 3rem;
            }

            textarea {
                resize: none;
                overflow: hidden;
                field-sizing: content;
            }

            .tooltip {
                position: relative;
                display: inline;
                cursor: pointer;
                margin-left: .4rem;
            }

            .tooltip-hoverspan {
                visibility: hidden;
                width: 15rem;
                background-color: black;
                color: #ffffff;
                text-align: center;
                padding: 5px 5px;
                border-radius: 6px;
                position: absolute;
                z-index: 1;
                margin-left: 1rem;
            }

            .tooltip-text {
                background-color: black;
                color: #ffffff;
                text-align: center;
                border-color: transparent;
            }

            .tooltip:hover .tooltip-hoverspan {
                visibility: visible;
            }
        </style>

        <div hidden id="upload_progress">
            <span><b>WARNING: Using the public image proxy will result in longer wait times (upto 5 minutes), please be patient!</b></span>
            <pre id="upload_status"></pre>
            <button id="abortupload">Abort Upload</button>
        </div>


        <a id="download" href="#" download="export.rbxmx" style="display:none;">Download</a>

        <div>
            <button id="convselect">Convert Selection</button>
            <div>
                <select name="presets" id="presets">
                    <option value="Full HD">Full HD (1920x1080 16:9)</option>
                    <option value="2K">2K (2048x1440 4:3)</option>
                    <option value="1440p">1440p (2560x1440 16:9)</option>
                    <option value="4K">4K (3840x2160 16:9)</option>
                </select>
                <button id="createpreset">Create Preset</button>
            </div>
        </div>

        <br>

        <div>
            <input type="checkbox" id="HighlightNodes" name="Highlight Nodes" />
            <label for="HighlightNodes">Highlight Nodes (WIP)</label>
            <div class="tooltip">
                <svg class="info-marker" fill="var(--figma-color-text-brand)"></svg>
                <div class="tooltip-hoverspan">
                    <span class="tooltip-text">Highlights all nodes/elements that are exported with special properties (Images, Buttons, ScrollingFrames)</span>
                </div>
            </div>
            <div></div>

            <input type="checkbox" id="ApplyAspectRatio" name="Apply AspectRatio" />
            <label for="ApplyAspectRatio">Apply AspectRatio globally</label>
            <div class="tooltip">
                <svg class="info-marker"></svg>
                <div class="tooltip-hoverspan">
                    <span class="tooltip-text">Enable this if you want everything to be exported with an AspectRatioConstraint</span>
                </div>
            </div>
            <div></div>

            <input type="checkbox" id="ApplyPadding" name="Apply AspectRatio" />
            <label for="ApplyPadding">Apply Padding to AutoLayouts</label>
            <div></div>

            <input type="checkbox" id="ApplyLayoutOrder" name="Apply LayoutOrder" />
            <label for="ApplyLayoutOrder">Apply Local LayoutOrder</label>
            <div class="tooltip">
                <svg class="info-marker"></svg>
                <div class="tooltip-hoverspan">
                    <span class="tooltip-text">Enable this if you want LayoutOrders to be applied, in ascending order from top to bottom</span>
                </div>
            </div>
            <div></div>

            <label for="ConvertAutoLayouts">
                <input type="checkbox" id="ConvertAutoLayouts" name="Convert AutoLayouts" />
                Convert AutoLayouts to UI Layouts AND/OR ScrollingFrames
                <div class="tooltip">
                    <svg class="info-marker"></svg>
                    <div class="tooltip-hoverspan">
                        <span class="tooltip-text">Enable this to automatically convert Frames with AutoLayouts enabled into ScrollingFrames, and/or add UI Grid/List Layouts</span>
                    </div>
                </div>
            </label>

            <label for="ApplyAnchorPoint">
                <input type="checkbox" id="ApplyAnchorPoint" name="Apply AnchorPoint" />
                Apply AnchorPoint globally
            </label>
            <label for="SnapAnchorPoint">
                <input type="checkbox" id="SnapAnchorPoint" name="Snap AnchorPoint" />
                Snap AnchorPoint to a 2x2 grid
            </label>
            <div></div>

            <label for="ConvertOffsetToScale">
                <input type="checkbox" id="ConvertOffsetToScale" name="Convert to Scale" />
                Convert to Scale
            </label>
            <div class="tooltip">
                <svg class="info-marker"></svg>
                <div class="tooltip-hoverspan">
                    <span class="tooltip-text">Will export all Elements with Scaled Position, rather than Offsetted Position (pixels)</span>
                </div>
            </div>
            <div></div>

            <label for="Recentre">
                <input type="checkbox" id="Recentre" name="Recentre" />
                Recentre
                <div class="tooltip">
                    <svg class="info-marker"></svg>
                    <div class="tooltip-hoverspan">
                        <span class="tooltip-text">Recentres the top-most Element to be at (0,0) when exported, rather than it's position within figma</span>
                    </div>
                </div>
            </label>
            <div></div>

            <label for="IgnoreInvisible">
                <input type="checkbox" id="IgnoreInvisible" name="Ignore Invisible" />
                Ignore Invisible Elements
                <div class="tooltip">
                    <svg class="info-marker"></svg>
                    <div class="tooltip-hoverspan">
                        <span class="tooltip-text">Will skip over Invisible Elements when exporting, so they will not be exported to Roblox</span>
                    </div>
                </div>
            </label>
            <div></div>

            <label for="ScaleScrollFramesDominantAxis">
                <input type="checkbox" id="ScaleScrollFramesDominantAxis" name="Only Scale Scroll Elements' Dominant Axis" />
                Only Scale Scroll Elements' Dominant Axis
                <div class="tooltip">
                    <svg class="info-marker"></svg>
                    <div class="tooltip-hoverspan">
                        <span class="tooltip-text">Enable this if you want your exported ScrollingFrames to only scroll in one direction, that being the dominant axis (decided on a per-element basis)</span>
                    </div>
                </div>
            </label>
        </div>

        <div>
            <h4>Image Uploading (optional):</h4>

            <input type="checkbox" id="uploadimages" name="Upload Images" />
            <label for="uploadimages">Upload Images</label>
            <div class="tooltip">
                <svg class="info-marker"></svg>
                <div class="tooltip-hoverspan">
                    <span class="tooltip-text">Enable this if you want any Images to be exported to Roblox</span>
                </div>
            </div>
            <div></div>

            <label for="alwaysexportimages"><input type="checkbox" id="alwaysexportimages" name="Export ImageLabels (applies if Uploading is disabled)"/> Export ImageLabels <small>(only applies if Uploading is disabled)</small></label>
            <div></div>
            <label for="DownloadImages"><input type="checkbox" id="DownloadImages" name="Export Images as zip"/>Export Images as zip</label>
            <div></div>

            <!-- <input type="checkbox" id="forcereupload" name="Force Reupload Images" />
            <label for="forcereupload">Force Reupload Images</label>
            <div></div> -->

            <!-- <input type="checkbox" id="reuploadstuck" name="Reupload Stuck Images" />
            <label for="reuploadstuck">Reupload Stuck Images</label>
            <div></div> -->

            <!-- <input type="checkbox" id="awaitmoderation" name="Await Moderation" />
            <label for="awaitmoderation">Await Moderation</label>
            <div></div> -->

            <input type="checkbox" id="IgnoreImageStrokeExport" name="Export Image Strokes Separately" />
            <label for="IgnoreImageStrokeExport">Export Image Strokes Separately</label>
            <div class="tooltip">
                <svg class="info-marker"></svg>
                <div class="tooltip-hoverspan">
                    <span class="tooltip-text">Enable this if you want control over an Image's Stroke within Roblox (otherwise the stroke will be applied into the image)</span>
                </div>
            </div>
            <div></div>

            <input type="checkbox" id="uploadeffects" name="Upload effects" />
            <label for="uploadeffects">Upload effects</label>
            <div></div>

            <label for="apikey">Cloud API Key</label>
            <div class="tooltip">
                <svg class="info-marker"></svg>
                <div class="tooltip-hoverspan">
                    <span class="hovertip-text">An API Key is required in order to upload images!</span>
                    <a href="https://create.roblox.com/dashboard/credentials?activeTab=ApiKeysTab" target="_blank">Create an API Key here</a>
                    <a href="https://img.lightshot.app/J5HoXWWaTjiTpOYMiStWAQ.png" target="_blank"><image src="https://img.lightshot.app/J5HoXWWaTjiTpOYMiStWAQ.png" /></a>
                </div>
            </div>
            <input type="text" id="apikey" placeholder="XXXXXXXXXXXXXXXXXXXXXXXXXXX" />
            <div></div>

            <label for="uploaderid">User/Group Id</label>
            <input type="text" id="uploaderid" placeholder="xxxxxxxxxx" />
            <div></div>

            <label for="uploadertype">Uploader Type</label>
            <select name="uploadertype" id="uploadertype" style="height: 40px">
                <option value="user">User</option>
                <option value="group">Group</option>
            </select>

            <input type="checkbox" id="uselocalproxy" name="Use Localhost Proxy" />
            <label for="uselocalproxy">Use Localhost Proxy</label>
            <div class="tooltip">
                <svg class="info-marker"></svg>
                <div class="tooltip-hoverspan">
                    <span class="tooltip-text">Enable this if you are using the locally hosted proxy from</span>
                    <a href="https://github.com/NoTwistedHere/Figma-to-Roblox/tree/proxy" target="_blank">GitHub</a>
                </div>
            </div>
            <div></div>

            <!-- <input type="checkbox" id="isgroup" name="Is Group" />
            <label for="isgroup">Upload To Group</label>
            <div></div> -->

            <!-- <label for="prox">Custom Proxy</label>
            <input type="text" id="prox" placeholder="Proxy URL" />
            <div></div> -->

            <!-- <input type="checkbox" id="exportImages" name="Export Images" />
            <label for="exportImages">Export Images</label> -->

            <details>
                <summary>
                    Plugin Help
                </summary>
                <p>You can often find more detailed information on <a href="https://github.com/NoTwistedHere/Figma-to-Roblox/blob/main/README.md" target="_blank">github</a></p>
                <h4>Tags are not case sensitive. Alternative names (alt tags) are removed from name on export</h4>
                Supported Tags:
                <ul>
                    <li>Image (alt: <b>IMG</b>)</li>
                    <li>Button (alt: <b>BTN</b>)</li>
                    <li>Scroll (alt: <b>SCRL</b>)</li>
                </ul>
                Supported Modifiers:
                <ul>
                    <li><b>|ANCHOR</b> - Enable AnchorPoint</li>
                </ul>
                <p style="font-size: small">With tags you can add the same to both TextLabel (or Buttons) and its parent Group, for better linking</p>
                <p style="font-size: small">Frames with the name <b>'Background'</b> will override their parent group's apperance once exported.</p>
                <p style="font-size: small">Frames with Auto Layout enabled will automatically export as a Scrolling Frame.</p>
            </details>
        </div>

        <!--  -->

        <h5>
            <span>Made by NoTwistedHere,</span>
            <br>
            <span>
                Please report bugs, and/or make suggestions in our <a href="https://discord.gg/DWCGss4vry" target="_blank">Discord server</a>.
            </span>
            <button id="copy_config">Copy Config to Clipboard</button>
        </h5>

        <script>
            var Settings = {};
            const Options = [
                {
                    name: "UploadImages",
                    id: "uploadimages",
                    type: "checkbox",
                },
                {
                    name: "AlwaysExportImages",
                    id: "alwaysexportimages",
                    type: "checkbox",
                },
                {
                    name: "DownloadImages",
                    id: "DownloadImages",
                    type: "checkbox",
                },
                {
                    name: "ForceUploadImages",
                    id: "forcereupload",
                    type: "checkbox",
                    no_save: true
                },
                {
                    name: "AwaitModeration",
                    id: "awaitmoderation",
                    type: "checkbox"
                },
                {
                    name: "IgnoreImageStrokeExport",
                    id: "IgnoreImageStrokeExport",
                    type: "checkbox"
                },
                {
                    name: "ReuploadStuckImages",
                    id: "reuploadstuck",
                    type: "checkbox",
                    no_save: true
                },
                {
                    name: "UploadEffects",
                    id: "uploadeffects",
                    type: "checkbox"
                },

                {
                    name: "ShowHighlights",
                    id: "HighlightNodes",
                    type: "checkbox",
                    instantUpdate: true,
                },
                {
                    name: "UseLocalProxy",
                    id: "uselocalproxy",
                    type: "checkbox"
                },
                {
                    name: "CloudApiKey",
                    id: "apikey",
                    type: "text",
                    placeholder: "XXXXXXXXXXXXXXXXXXXXXXXXXXX",
                },
                {
                    name: "UploaderId",
                    id: "uploaderid",
                    type: "text",
                    placeholder: "xxxxxxxxxx",
                },
                {
                    name: "UploaderType",
                    id: "uploadertype",
                    type: "text",
                    default: "user"
                },

                {
                    name: "UseSelectionPositionRelativeToScene",
                    id: "Recentre",
                    type: "checkbox",
                    flipped: true
                },
                {
                    name: "ApplyAspectRatio",
                    id: "ApplyAspectRatio",
                    type: "checkbox",
                },
                {
                    name: "ApplyPadding",
                    id: "ApplyPadding",
                    type: "checkbox",
                },
                {
                    name: "ApplyLayoutOrder",
                    id: "ApplyLayoutOrder",
                    type: "checkbox"
                },
                {
                    name: "ConvertOffsetToScale",
                    id: "ConvertOffsetToScale",
                    type: "checkbox",
                },
                {
                    name: "ApplyAnchorPoint",
                    id: "ApplyAnchorPoint",
                    type: "checkbox",
                },
                {
                    name: "SnapAnchorPoint",
                    id: "SnapAnchorPoint",
                    type: "checkbox",
                },
                {
                    name: "IgnoreInvisible",
                    id: "IgnoreInvisible",
                    type: "checkbox",
                },
                {
                    name: "ScrollFrame_ScaleDominantAxis",
                    id: "ScaleScrollFramesDominantAxis",
                    type: "checkbox",
                },
                {
                    name: "ConvertAutoLayoutsToScrollFrames",
                    id: "ConvertAutoLayouts",
                    type: "checkbox",
                },
            ]

            let AbortUpload;
            let NumImagesTotal = 0;
            let NumImagesFinished = 0;
            let NumImagesPendingApproval = 0;
            let NumImagesFailed = 0;
            let ImageUploadController;
            let UploadDelay;
            let PendingImageDataUploads = [];
            let PendingImageOperations = [];
            let PendingImageUploads = [];

            const PLACEHOLDER_IMAGE = "rbxasset://textures/StudioSharedUI/TransparentWhiteImagePlaceholder.png";

            function PostMessage(Data) {
                parent.postMessage({ pluginMessage: Data }, "*");
            }

            const UploadStatus = document.getElementById("upload_status")

            function UpdateUploadStatus() {
                UploadStatus.textContent = `\nImage status:\nUploading: ${NumImagesTotal}    In Moderation: ${NumImagesPendingApproval}\nFinished: ${NumImagesFinished}/${NumImagesTotal}    Failed: ${NumImagesFailed}\n`
            }

            function PostImageUploaded(id, UploadResponse, CheckOp) {
                PostMessage({ type: "ImageUploaded", id: id, co: CheckOp, data: UploadResponse })
                UpdateUploadStatus();
            }

            function Sleep(ms) {
                return new Promise(res => setTimeout(res, ms));
            }

            Options.forEach(Option => {
                const Element = document.getElementById(Option.id);

                if (Element && Option.instantUpdate) {
                    Element.onclick = () => {
                        // ik I could use switch but is it really needed?
                        if (Option.type === "text") Value = Element.value
                        else if (Option.type === "checkbox") {
                            Value = Element.checked;

                            if (Option.flipped) Value = !Value
                        };

                        if (Value !== undefined && Settings[Option.name] !== Value) {
                            Settings[Option.name] = Value;
                            PostMessage({
                                type: "SetAsync",
                                key: Option.name,
                                value: Value,
                                no_save: Option.no_save,
                            });
                        }
                    };
                }
            });

            window.addEventListener("keydown", (Event) => {
                if (Event.key === "F8") {
                    Settings.ShowHighlights = !Settings.ShowHighlights;
                    document.getElementById("HighlightNodes").checked = Settings.ShowHighlights;
                    PostMessage({
                        type: "SetAsync",
                        key: "ShowHighlights",
                        value: Settings.ShowHighlights
                    });
                }
            });

            document.getElementById("copy_config").onclick = () => {
                const TempSanitisedSettings = {}

                for (var [key, value] of Object.entries(Settings)) {
                    switch (key) {
                        case "ImageUploadTestData":
                        case "CloudApiKey":
                        case "DefaultExport":
                            break;
                        default:
                            if (typeof(value) !== "string" || value.substr(0, 2) !== "n+") TempSanitisedSettings[key] = value;
                            break;
                    }
                }

                // Clipboard Stolen from Alex_FG on https://forum.figma.com/ask-the-community-7/write-to-clipboard-from-custom-plugin-23974
                const prevActive = document.activeElement;
                const textArea   = document.createElement('textarea');

                textArea.value = "## Config:\n```json\n" + JSON.stringify(TempSanitisedSettings, null, 4) + "```";
                textArea.style.position = 'fixed';
                textArea.style.left     = '-999999px';
                textArea.style.top      = '-999999px';

                document.body.appendChild(textArea);

                textArea.focus();
                textArea.select();

                if (document.execCommand('copy')) PostMessage({ type: "Notify", message: "Successfully copied config to clipboard!" })
                else PostMessage({ type: "Notify", error: true, message: "FAILED to copy config to clipboard!" });

                textArea.remove();
                prevActive.focus();
            }

            document.getElementById("convselect").onclick = () => {
                Options.forEach(Option => {
                    const Element = document.getElementById(Option.id);
                    if (!Element) return;
                    var Value;

                    // ik I could use switch but is it really needed?
                    if (Option.type === "text") Value = Element.value.replace(/[ \t\n\r]/g, "");
                    else if (Option.type === "checkbox") {
                        Value = Element.checked;

                        if (Option.flipped) Value = !Value
                    };

                    if (Value !== undefined && Settings[Option.name] !== Value) {
                        Settings[Option.name] = Value;
                        PostMessage({
                            type: "SetAsync",
                            key: Option.name,
                            value: Value,
                            no_save: Option.no_save
                        });

                        if (Option.no_save) {
                            Settings[Option.name] = false;
                            Element.checked = false;
                        }
                    }
                });

                StartedAt = Date.now();
                NumImagesTotal = 0;
                NumImagesFinished = 0;
                NumImagesPendingApproval = 0;
                NumImagesFailed = 0;
                AbortUpload = false;
                PostMessage({ type: 'run' });
            }
            document.getElementById("createpreset").onclick = () => {
                PostMessage({ type: 'CreatePreset', preset: document.getElementById("presets").value });
            }
            document.getElementById("abortupload").onclick = () => {
                if (!StartedAt) return;

                const SecondsSince = (Date.now() - StartedAt) / 1000;
                const MinWaitTime = 50;
                if (SecondsSince < MinWaitTime) {
                    PostMessage({ type: "Notify", error: true, timeout: 2000, message: `You must wait at least ${MinWaitTime} seconds before aborting, you can abort in: ${MinWaitTime - SecondsSince} seconds` });
                    return;
                }

                AbortUpload = true;

                if (UploadDelay) clearTimeout(UploadDelay);
                if (ImageUploadController) ImageUploadController.abort();

                UploadDelay = undefined;
                ImageUploadController = undefined;
                StartedAt = undefined;

                PostMessage({ type: 'AbortUpload' });
            }

            const DownloadLink = document.getElementById("download");
            var Images = [];

            function DownloadImages() {
                if (!Settings.DownloadImages || Images.length == 0) {
                    return;
                }

                while (JSZip === undefined) Sleep(200);

                let Zip = new JSZip();

                for (let i = 0; i < Images.length; i++) {
                    var Image = Images[i];
                    Zip.file(`${Image.Name}(${i}).png`, Image.ImageBlob);
                }

                Zip.generateAsync({ type: "blob" }).then((Content) => {
                    DownloadLink.href = URL.createObjectURL(Content);
                    DownloadLink.download = "images.zip";
                    DownloadLink.click();
                });

                Images = [];
            }

            function UploadImages() {
                ImageUploadController = new AbortController();
                UploadDelay = undefined;

                try {
                    // TODO: Select proxy based on IP's TimeZone (or allow user to select their region between America, Europe & Asia)

                    fetch(Settings.UseLocalProxy ? "http://localhost:10582" : "https://figma-to-roblox-proxy.onrender.com", {
                        method: "POST",
                        signal: ImageUploadController.signal,
                        headers: {
                            ["p"]: Settings.UseLocalProxy ? "f1a8" : "f1a8",
                            ["k"]: Settings.CloudApiKey,
                            ["Content-Type"]: "application/json"
                        },
                        body: JSON.stringify([
                            parseFloat(Settings.UploaderId),
                            Settings.UploaderType === "user" ? 0 : 1,
                            PendingImageDataUploads
                        ])
                    })
                    .then(async res => {
                        const Response = await res.text();
                        const ImageUploadResults = Response.match(/([bes]:[^\n]+)/mg);
                        NumImagesFinished = NumImagesTotal; // server can return a single error message for multiple uploads

                        ImageUploadResults.forEach((RawUploadResponse, ImageIndex) => {
                            const ImageUploadRequest = PendingImageUploads[ImageIndex];
                            const [_, Type, UploadResponse] = RawUploadResponse.match(/([bes]):(.*)\n?/)

                            console.log(ImageUploadRequest, Type, UploadResponse)

                            switch (Type) {
                                case "b": // Success (body / asset id)
                                    if (UploadResponse.match(/^op-/)) {
                                        console.log("saving Upload Operation Id:", UploadResponse.match(/^op-(.*)/)[1])
                                        PostMessage({type: "UpdateOperationId", id: ImageUploadRequest.Id, data: UploadResponse.match(/^op-(.*)/)[1], co: true});
                                        // TODO: TEMPORARY, While Upload Operations aren't acted upon:
                                        PostImageUploaded(ImageUploadRequest.Id, {
                                            assetId: PLACEHOLDER_IMAGE
                                        })
                                    } else PostImageUploaded(ImageUploadRequest.Id, {
                                        assetId: UploadResponse
                                    })
                                    break;
                                case "s": // Issue (status code)
                                    console.error(`Server returned an issue "${UploadResponse}"`);
                                    PostMessage({ type: "UploadError", message: "Roblox error code: \"" + UploadResponse + "\"" });
                                    PostImageUploaded(ImageUploadRequest.Id, {
                                        imageContent: PLACEHOLDER_IMAGE
                                    });
                                    break;
                                case "e": // Error (error)
                                    console.error(`Server returned an error "${UploadResponse}"`);
                                    PostMessage({ type: "UploadError", message: "Roblox error message: \"" + UploadResponse + "\""  });
                                    PostImageUploaded(ImageUploadRequest.Id, {
                                        imageContent: PLACEHOLDER_IMAGE
                                    });
                                    break;
                            }
                        })

                        PendingImageUploads = [];
                    })
                    .catch(async res => {
                        const Message = `"${res.statusText || res.message}"`;
                        console.error(`Server returned unexpected response: ${Message}`);

                        NumImagesFinished += 1;
                        PostMessage({ type: "UploadError", message: Message || "Proxy server error" });

                        PendingImageUploads.forEach(data => {
                            PostImageUploaded(data.Id, {
                                imageContent: PLACEHOLDER_IMAGE
                            });
                        })

                        PendingImageUploads = [];
                    })

                    PendingImageDataUploads = [];
                } catch (e) {
                    console.error(`Server returned unexpected response: "${e}"`);

                    NumImagesFinished += 1;
                    PendingImageUploads = [];
                    PostMessage({ type: "UploadError", message: (e && e.message) || "Proxy server error" });
                    PostImageUploaded(data.Id, {
                        imageContent: PLACEHOLDER_IMAGE
                    });
                }
            }

            // async function CheckOperations(data, i) {
            //     try {
            //         // TODO: Select proxy based on IP's TimeZone (or allow user to select their region between America, Europe & Asia)

            //         fetch(Settings.UseLocalProxy ? "http://localhost:10582" : "https://figma-to-roblox-proxy.onrender.com", {
            //             method: "POST",
            //             signal: ImageUploadController.signal,
            //             headers: {
            //                 ["p"]: Settings.UseLocalProxy ? "f1a8" : "f1a8",
            //                 ["k"]: Settings.CloudApiKey,
            //                 ["Content-Type"]: "application/json"
            //             },
            //             body: PendingImageOperations.join(",") // ik, not actually json - to save on bandwidth + easier to decode
            //         })
            //         .then(async res => {
            //             const Response = await res.text();
            //             const ImageUploadResults = Response.match(/([bes]:[^\n]+)/mg);
            //             NumImagesFinished = NumImagesTotal; // server can return a single error message for multiple uploads

            //             ImageUploadResults.forEach((RawUploadResponse, ImageIndex) => {
            //                 const ImageUploadRequest = PendingImageUploads[ImageIndex];
            //                 const [_, Type, UploadResponse] = RawUploadResponse.match(/([bes]):(.*)\n?/)

            //                 console.log(ImageUploadRequest, Type, UploadResponse)

            //                 switch (Type) {
            //                     case "b": // Success (body / asset id)
            //                         if (UploadResponse.match(/^op-/)) {
            //                             console.log("saving Upload Operation Id:", UploadResponse.match(/^op-(.*)/)[1])
            //                             PostMessage({type: "UpdateOperationId", id: ImageUploadRequest.Id, data: UploadResponse.match(/^op-(.*)/)[1], co: true});
            //                         } else PostImageUploaded(ImageUploadRequest.Id, {
            //                             assetId: UploadResponse
            //                         })
            //                         break;
            //                     case "s": // Issue (status code)
            //                         console.error(`Server returned an issue "${UploadResponse}"`);
            //                         PostMessage({ type: "UploadError", message: "Roblox error code: \"" + UploadResponse + "\"" });
            //                         PostImageUploaded(ImageUploadRequest.Id, {
            //                             imageContent: PLACEHOLDER_IMAGE
            //                         });
            //                         break;
            //                     case "e": // Error (error)
            //                         console.error(`Server returned an error "${UploadResponse}"`);
            //                         PostMessage({ type: "UploadError", message: "Roblox error message: \"" + UploadResponse + "\""  });
            //                         PostImageUploaded(ImageUploadRequest.Id, {
            //                             imageContent: PLACEHOLDER_IMAGE
            //                         });
            //                         break;
            //                 }
            //             })

            //             // if (parseInt(Response)) {
            //             //     PostImageUploaded(data.Id, {
            //             //         assetId: Response
            //             //     })
            //             // } else {
            //             //     console.error(`Server returned unexpected response: "${Response}"\nstatus: ${res.status}: "${res.statusText}"`);
            //             //     PostMessage({ type: "UploadError", message: Response && Response != "" ? Response : "Error code: " + res.statusText });
            //             //     PostImageUploaded(data.Id, {
            //             //         imageContent: PLACEHOLDER_IMAGE
            //             //     });
            //             // }
            //         })
            //         .catch(async res => {
            //             const Message = `"${res.statusText || res.message}"`;
            //             console.error(`Server returned unexpected response: ${Message}`);

            //             NumImagesFinished += 1;
            //             PostMessage({ type: "UploadError", message: Message || "Proxy server error" });
            //             PostImageUploaded(data.Id, {
            //                 imageContent: PLACEHOLDER_IMAGE
            //             });
            //         })
            //         PendingImageOperations = [];
            //     } catch (e) {
            //         console.error(`Server returned unexpected response: "${e}"`);

            //         NumImagesFinished += 1;
            //         PostMessage({ type: "UploadError", message: (e && e.message) || "Proxy server error" });
            //         PostImageUploaded(data.Id, {
            //             imageContent: PLACEHOLDER_IMAGE
            //         });
            //     }
            // }

            onmessage = async (event) => {
                const { type, data, wait } = event.data.pluginMessage;

                switch (type) {
                    case "Download":
                        DownloadLink.href = "data:text/xml;charset=utf-8," + encodeURIComponent(data);
                        DownloadLink.download = (data.name || "export") + ".rbxmx";
                        DownloadLink.click();

                        NumImagesTotal = 0;
                        NumImagesFinished = 0;
                        NumImagesPendingApproval = 0;
                        NumImagesFailed = 0;

                        setTimeout(() => {
                            if (NumImagesTotal === 0) {
                                document.getElementById("upload_progress").setAttribute("hidden", true);
                                UploadStatus.textContent = "";
                            }
                        }, 5000);

                        DownloadImages();
                        break;
                    // case "CheckOperation":
                    //     if (AbortUpload) return;
                    //     PendingImageOperations.push(data.operationId || data.Id)

                    //     if (!CheckOpsDelay) {
                    //         CheckOpsDelay = setTimeout(UploadImages, 800)
                    //     }
                    //     break;
                    case "ExportImage":
                        if (Settings.DownloadImages) {
                            const blob = new Blob([data.Data.buffer], { type: "image/" + data.Format });

                            data.ImageBlob = blob;
                            Images.push(data);
                        }
                        break;
                    case "UploadImage":
                        if (!Settings.UploadImages) {
                            console.warn("[Figma to Roblox] Tried exporting Image, but Upload Images is disabled")
                            PostImageUploaded(data.Id, {
                                imageContent: PLACEHOLDER_IMAGE
                            });
                            return;
                        } else if (!Settings.CloudApiKey || !Settings.UploaderId || Settings.CloudApiKey.length !== 964 || Settings.UploaderId == "") {
                            console.warn("Cloud API Key is not set");
                            PostMessage({ type: "UploadError", message: "Cloud API Key is not set, please create one at: https://create.roblox.com/dashboard/credentials?activeTab=ApiKeysTab\n" });
                            PostImageUploaded(data.Id, {
                                imageContent: PLACEHOLDER_IMAGE
                            });
                            return;
                        }

                        if (AbortUpload) return;
                        NumImagesTotal += 1;
                        UpdateUploadStatus();

                        const blob = new Blob([data.Data.buffer], { type: "image/" + data.Format });

                        if (data.Name === "") data.Name = "ExportedImage";
                        if (Settings.DownloadImages) {
                            data.ImageBlob = blob;
                            Images.push(data);
                        }

                        const bytes = [];
                        data.Data.forEach(b => bytes.push(b))

                        PendingImageDataUploads.push([
                            data.Name + "." + data.Format,
                            bytes
                        ])
                        PendingImageUploads.push(data)

                        if (!UploadDelay) {
                            document.getElementById("upload_progress").removeAttribute("hidden");
                            UploadDelay = setTimeout(UploadImages, 800)
                        }

                        break;

                    case "LoadSettings":
                        Settings = event.data.pluginMessage.settings;

                        Options.forEach(Option => {
                            const Element = document.getElementById(Option.id);

                            if (Element) {
                                const Value = Settings[Option.name];

                                // ik I could use switch but is it really needed?
                                if (Option.type === "text") Element.value = Value || Option.default || ""
                                else if (Option.type === "checkbox") {
                                    Element.checked = Value || false;

                                    if (Option.flipped) Element.checked = !Element.checked
                                };
                            }
                        });

                        break;
                };
            };
        </script>
    </body>
</html>